/** Copyright 2013 Google Inc.
 *  Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Authors: Jim Burton, Miron Cuperman, Andreas Schildbach, John L. Jegutanis
 */

/* Notes:
 * - Endianness: All byte arrays that represent numbers (such as hashes and private keys) are Big Endian
 * - To regenerate after editing, run: mvn generate-sources -DupdateProtobuf
 */

package com.coinomi.core.protos;

option java_package = "com.coinomi.core.protos";

option java_outer_classname = "Protos";

message PeerAddress {
    required bytes ip_address = 1;
    required uint32 port = 2;
    required uint64 services = 3;
}

message EncryptedData {
    required bytes initialisation_vector = 1; // The initialisation vector for the AES encryption (16 bytes)
    required bytes encrypted_private_key = 2; // The encrypted private key
}

/**
 * Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm.
 */
message DeterministicKey {
    // Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
    // should just treat it as a regular ORIGINAL type key.
    required bytes chain_code = 1;

    // The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
    // and high bit unset for public derivation.
    repeated uint32 path = 2;

    // How many children of this key have been issued, that is, given to the user when they requested a fresh key?
    // For the parents of keys being handed out, this is always less than the true number of children: the difference is
    // called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
    // this wallet - for instance when restoring from backup or if the seed was shared between devices.
    //
    // If this field is missing it means we're not issuing subkeys of this key to users.
    optional uint32 issued_subkeys = 3;
    optional uint32 lookahead_size = 4;

    /**
     * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
     * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
     * a single P2SH multisignature address
     */
    optional bool isFollowing = 5;
}

/**
 * A key used to control Bitcoin spending.
 *
 * Either the private key, the public key or both may be present.  It is recommended that
 * if the private key is provided that the public key is provided too because deriving it is slow.
 *
 * If only the public key is provided, the key can only be used to watch the blockchain and verify
 * transactions, and not for spending.
 */
message Key {
    enum Type {
        /** Unencrypted - Original bitcoin secp256k1 curve */
        ORIGINAL = 1;

        /** Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve */
        ENCRYPTED_SCRYPT_AES = 2;

        /**
        * Not really a key, but rather contains the mnemonic phrase for a deterministic key hierarchy in the private_key field.
        * The label and public_key fields are missing. Creation timestamp will exist.
        */
        DETERMINISTIC_MNEMONIC = 3;

        /**
         * A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
         * wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
         * However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
         * is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
         * key can be rederived on the fly.
         */
        DETERMINISTIC_KEY = 4;
    }
    required Type type = 1;

    // Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
    // If the secret is encrypted, or this is a "watching entry" then this is missing.
    optional bytes secret_bytes = 2;
    // If the secret data is encrypted, then secret_bytes is missing and this field is set.
    o